<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>MongoDB Schema Design Workshop</title>
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <link rel="stylesheet" href="../vendor/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../vendor/highlight.js/src/styles/github.css">

        <script>
            // If the query includes 'print-pdf' we'll use the PDF print sheet
            document.write('<link rel="stylesheet" href="../vendor/reveal.js/css/print/' + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper') + '.css" type="text/css" media="print">');
        </script>

        <link rel="stylesheet" href="../common/css/theme.10gen.css">
        <link rel="stylesheet" href="css/main.css">

        <!--[if lt IE 9]>
        <script src="../common/reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="state-background"></div>

            <div class="slides">
                <section data-state="title">
                    <h1><span class="logo-mongodb">MongoDB</span> Schema Design</h1>

                    <p class="bio">Jeremy Mikola<br><a href="http://twitter.com/jmikola">@jmikola</a></p>
                </section>


                <section>
                    <section data-markdown>
                        # What is a schema?
                    </section>

                    <section data-markdown>
                        ## 3 inputs to Schema Design in mongoDB

                        1. The data your application needs.
                        2. Your application's read usage of the data.
                        3. Your application's write usage of the data.
                    </section>

                </section>

                <section>

                    <section data-markdown>
                        ## Why is schema design important?

                        Schema is defined at the application-level

                        Flexible schema benefits Development phase

                        Good schema needed for production

                        Schema evolves to meet future business needs
                    </section>

                    <section data-markdown>
                        ## MongoDB is a document database

                        Documents are stored in BSON

                        Each document has keys and values
                    </section>

                    <section data-markdown class="ul-2col">
                        ## BSON data types
                        <a href="http://bsonspec.org/">BSONSpec.org</a>

                        * Scalars
                            * Double
                            * UTF-8 String
                            * Binary
                            * ObjectId
                            * Boolean
                            * UTC DateTime
                            * Null
                            * Regular Expression
                            * 32-bit Integer
                            * Timestamp
                            * 64-bit Integer
                        * Rich types
                            * Documents
                            * Arrays
                    </section>
                </section>

                <section>

                    <section data-markdown>
                        ## Library web application

                        Different schemas are possible
                    </section>

                    <section data-markdown>
                        ## Author schema
<pre><code class="language-javascript">{
    "_id": int,
    "first_name": string,
    "last_name": string
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## User schema
<pre><code class="language-javascript">{
    "_id": int,
    "username": string,
    "password": string
}</code></pre>
                    </section>


                    <section data-markdown>
                        ## Book schema
<pre><code class="language-javascript">{
    "_id" : int,
    "author" : int,
    "available" : boolean,
    "created_at" : date,
    "created_by" : date,
    "isbn" : string,
    "language" : string,
    "pages" : int,
    "publisher" : {
        "city" : string,
        "name" : string
    },
    "slug" : string,
    "subjects" : [
         string,
         string
   ],
    "title" : string
}</code></pre>

                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Terminology

                        tables -- collections

                        joins -- embedding and linking

                        rows -- documents

                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Sample documents
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
}</code></pre>
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">db.users.findOne()
{
    _id: 1,
    username: "emily@10gen.com",
    password: "slsjfk4odk84k209dlkdj90009283d"
}</code></pre>
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">db.books.findOne()
{   _id: 1,
    title: "The Great Gatsbyss",
    slug: "9781857150193-the-great-gatsby",
    author:1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],

}</code></pre>
                    </section>
               </section>

               <section>
                    <section data-markdown>
                        # Embedded documents

                        What advantages do they have?

                        When should they be used?
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    <div class="code-highlight">    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },</div>
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
}</code></pre>
                    </section>
               </section>

               <section>
                    <section data-markdown>
                        # Linked documents

                        What advantages does this approach have?

                        When should they be used?
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    <div class="code-highlight">    author: 1, </div>
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
}</code></pre>
                    </section>

                    <section data-markdown>
                        <img src="img/memory.png">
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # Arrays

                        When should they be used?
                    </section>

                    <section data-markdown>
                        Array of Scalars
<pre><code class="language-javascript">db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    <div class="code-highlight">    subjects: ["Love stories", "1920s", "Jazz Age"], </div>
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
}</code></pre>
                     </section>

                    <section data-markdown>
                        Array of documents
<pre><code class="language-javascript">db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    <div class="code-highlight">    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
    </div>
}</code></pre>
                     </section>

                </section>

                <section>
                    <section data-markdown>
                        # Development Phase
                        Basic CRUD functions
                    </section>
                 </section>

                 <section>
                    <section data-markdown>
                        # Create
<pre><code class="language-javascript">
    author = {  _id: 2,
               first_name: "Arthur",
               last_name: "Miller"
    }

    db.authors.insert(author)

</code></pre>
                        *  <a href="http://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-BSONObjectIDSpecification">_id</a> is unique and automatically indexed
                        * An ObjectId will be generated by mongoDB if not provided
                    </section>
                 </section>
                 <section>
                    <section data-markdown>
                        # Read
<pre><code class="language-javascript">
    db.authors.find({ "last_name": "Miller" })

    {  _id: 2,
       first_name: "Arthur",
       last_name: "Miller"
    }

</code></pre>
                    </section>
                    <section data-markdown>
                        ## Add an Index
<pre><code class="language-javascript">
    db.authors.ensureIndex({ "last_name": 1 })
</code></pre>
                        ## Examine the query
<pre><code class="language-javascript">
db.authors.find({ "last_name": "Miller" }).explain()
{<div class="code-highlight">    "cursor": "BtreeCursor slug_1",</div>    "isMultiKey" : false,
    "n" : 1,
    "nscannedObjects" : 1,
    "nscanned" : 1,
    "scanAndOrder" : false,
    "indexOnly" : false,
    "nYields" : 0,
    "nChunkSkips" : 0,
    "millis" : 0,
.....
}
</code></pre>
                    </section>

                     <section data-markdown>
                         ## Multi-key indexes on arrays

<pre><code class="language-javascript">
     db.books.ensureIndex({ "subjects": 1 })

</code></pre>
                     </section>

                    <section data-markdown>
                         ## Indexes on embedded document keys

<pre><code class="language-javascript">
     db.books.ensureIndex({ "publisher.name": 1 })

</code></pre>
                     </section>

                    <section data-markdown>
                        ## Query operators

                        * Conditional operators
                            * <code>$all, $exists, $mod, $ne, $nin, $nor, $or, $and, $size, $type</code>
                        * Regular Expressions
                        * Value in an array
                            * <code>$elemMatch</code>
                        * Cursor methods
                            * <code>count(), limit(), skip(), snapshot(), sort(), batchSize()</code>
                    </section>
                 </section>

                 <section>
                    <section data-markdown>
                        # Update
<pre><code class="language-javascript">
     review = { user: 1, text: "I did NOT like this book." }
     db.books.update({ _id: 1 }, {$push: {reviews: review }})

</code></pre>
                    </section>
                    <section data-markdown class="ul-2col">
                        ## Take advantage of atomic operations
                        * $set
                        * $unset
                        * $inc
                        * $push
                        * $pushAll
                        * $pull
                        * $pullAll
                        * $bit
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # Remove
<pre><code class="language-javascript">
     db.books.remove({ _id: 1 })

</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Production Phase
                        Evolve schema to meet read and write usage needs
                    </section>
                </section>

                <section>

                    <section data-markdown>
                        ## Read usage
                        Searches for author by last name
<pre><code class="language-javascript">
     authors = db.authors.find( { first_name: /^f.*/i }, {_id: 1})
     authorIds = authors.map(function(x) { return x._id; })
     db.books.find({author: { $in: authorIds } })

</code></pre>
                    </section>

                    <section data-markdown>
                        Searches for books by title
<pre><code class="language-javascript">
     db.books.find({title:"TheGreat Gatsby"})

</code></pre>
                    </section>

                    <section data-markdown>
                        Find books that I have reviewed
<pre><code class="language-javascript">
     db.books.find({reviews.user:1})

</code></pre>
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        ## Write usage
                        Review a book
<pre><code class="language-javascript">
     review = { user: 1,
                text: "I did NOT like this book.",
                rating: 1 }

     db.books.update({ _id: 3 }, {$push: {reviews: review }})

</code></pre>
                        * 16mb document size limit
                        * Possible storage fragmentation with many updates
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # I Like Turtles
                    </section>
                </section>

                <section>
                    <section data-markdown class="ul-2col">
                        ## Exercise #1

                        Design a schema for user reviews for books.

                        * Users
                            * username (string)
                            * email (string)
                        * Reviews
                            * text (string)
                            * rating (integer)

                        *Usernames are immutable.*
                    </section>

                    <section data-markdown class="ul-2col">
                        ### Exercise #1: Solution A

                        <pre><code class="language-javascript">// db.users (one document per user)
{
  _id: ObjectId("…"),
  username: "bob",
  email: "bob@example.com"
}</code></pre>

                        <pre><code class="language-javascript">// db.reviews (one document per review)
{
  _id: ObjectId("…"),
  user: ObjectId("…"),
  book: ObjectId("…"),
  rating: 5,
  text: "This book is excellent!",
  created_at: ISODate("2012-10-10T21:14:07.096Z")
}</code></pre>
                    </section>

                    <section data-markdown class="ul-2col">
                        ### Exercise #1: Solution B

                        <pre><code class="language-javascript">// db.users (one document per user with all reviews)
{
  _id: ObjectId("…"),
  username: "bob",
  email: "bob@example.com",
  reviews: [
    {
      book: ObjectId("…"),
      rating: 5,
      text: "This book is excellent!",
      created_at: ISODate("2012-10-10T21:14:07.096Z")
    }
  ]
}</code></pre>
                    </section>

                    <section data-markdown class="ul-2col">
                        ### Exercise #1: Solution C

                        <pre><code class="language-javascript">// db.users (one document per user)
{
  _id: ObjectId("…"),
  username: "bob",
  email: "bob@example.com"
}</code></pre>

                        <pre><code class="language-javascript">// db.books (one document per book with all reviews)
{
  _id: ObjectId("…"),
  // Other book fields
  reviews: [
    {
      user: ObjectId("…"),
      rating: 5,
      text: "This book is excellent!",
      created_at: ISODate("2012-10-10T21:14:07.096Z")
    }
  ]
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #2

                        Display a user's most recent 10 book reviews.

                        Make efficient use of memory and disk seeks.
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Store users' reviews in monthly buckets.

                        <pre><code class="language-javascript">// db.reviews (one document per user per month)
{
  _id: "bob-2012-10",
  reviews: [
    {
      rating: 5,
      text: "This book is excellent!",
      created_at: ISODate("2012-10-10T21:14:07.096Z")
    },
    {
      rating: 2,
      text: "I didn't really enjoy this book.",
      created_at: ISODate("2012-10-11T20:12:50.594Z")
    }
  ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Adding a new review to the appropriate bucket.

                        <pre><code class="language-javascript">myReview = {
  rating: 3
  text: "An average read."
  created_at: ISODate("2012-10-13T12:26:11.502Z")
}

db.reviews.update(
  { _id: "bob-2012-10" },
  { $push: { reviews: myReview }
);</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Display a user's most recent 10 book reviews.

                        <pre><code class="language-javascript">cursor = db.reviews.find(
  { _id: /^bob-/ },
  { reviews: { $slice: 10 }}
).sort({ _id: -1 });

num = 0;

while (cursor.hasNext() &amp;&amp; num &lt; 10) {
  doc = cursor.next();

  for (var i = 0; i &lt; doc.reviews.length && num < 10; ++i, ++num) {
    printjson(doc.reviews[i]);
  }
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Deleting a review.

                        <pre><code class="language-javascript">cursor = db.reviews.update(
  { _id: "bob-2012-10" },
  { $pull: {
      reviews: { created_at: ISODate("2012-10-13T12:26:11.502Z") }
    }
  }
);</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #3

                        Allow users to follow one another.

                        * User sends a follow request
                        * Followee approves or not
                        * Requests time out after seven days

                        Approval process is asynchronous.
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        * Need to maintain order and state
                        * Ensure that updates are atomic

                        <pre><code class="language-javascript">db.approvals.insert({
  _id: { follower: "bob", followee: "mary" },
  in_progress: false,
  approved: false,
  priority: 1,
});

// Find the highest priority approval and mark as in progress
approval = db.approvals.findAndModify({
  query: { in_progress: false },
  sort: { priority: -1 },
  update: { $set: { in_progress: true, started: new ISODate() }},
  new: true
});</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        <pre><code class="language-javascript">{
  _id: { follower: "bob", followee: "mary" },
  in_progress: true, // updated
  approved: false,
  priority: 1,
  started: ISODate("2012-10-11T22:09:42.542Z") // added
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        <pre><code class="language-javascript">// Followee approves request
db.approvals.update(
  { _id: { follower: "bob", followee: "mary" }},
  { $set: { inprogress: false, approved: true }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        <pre><code class="language-javascript">limit = new Date();
limit.setDate(limit.getDate() - 7);

// Time out requests after seven days
db.approvals.update(
  { inprogress: true, started: { $lt: limit }},
  { $set: { inprogress: false, approved: false }}
);</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #4

                        Allow users to upvote a review.

                        * Users can upvote a review only once
                        * Display a review's current upvotes
                    </section>

                    <section data-markdown>
                        ## Exercise #4: Solution

                        <pre><code class="language-javascript">// db.votes (one document per voter per review)
db.votes.insert({
  review: ObjectId("…"),
  user: ObjectId("…")
});

// Unique index ensures users can't vote twice
db.votes.ensureIndex({ review: 1, user: 1 }, { unique: true });

// Count the number of upvotes for a review
db.votes.count({ review: ObjectId("…") });</code></pre>
                    </section>

                    <section data-markdown>
                        ## Exercise #4: Solution

                        Denormalize upvote totals on reviews.

                        <pre><code class="language-javascript">db.reviews.update(
  { _id: ObjectId("…") },
  { $inc: { votes: 1 }}
});</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #5

                        Tracking time series data.

                        * Count upvotes by: day, hour, minute
                        * Show time series of votes cast
                    </section>

                    <section data-markdown>
                        ## Exercise #5: Solution

                        <pre><code class="language-javascript">// db.votes_ts (one document per review per day of votes)
db.votes_ts.update(
  { review: ObjectId("…"),
    day: ISODate("2012-10-11T00:00:00.000Z") }
  { user: ObjectId("…")
});

// Unique index ensures users can't vote twice
db.votes.ensureIndex({ review: 1, user: 1 }, { unique: true });

// Count the number of upvotes for a review
db.votes.count({ review: ObjectId("…") });</code></pre>
                    </section>

                    <section data-markdown>
                        ## Exercise #4: Solution

                        Denormalize upvote totals on reviews.

                        <pre><code class="language-javascript">db.reviews.update(
  { _id: ObjectId("…") },
  { $inc: { votes: 1 }}
});</code></pre>
                    </section>
                </section>
            </div>

            <div class="footer"></div>
        </div>

        <script src="../vendor/reveal.js/lib/js/head.min.js"></script>
        <script src="../vendor/reveal.js/js/reveal.js"></script>
        <script src="../common/js/reveal.js"></script>
    </body>
</html>
