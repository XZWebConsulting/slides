<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>MongoDB Schema Design Workshop</title>
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <link rel="stylesheet" href="../vendor/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../vendor/highlight.js/src/styles/github.css">

        <script>
            // If the query includes 'print-pdf' we'll use the PDF print sheet
            document.write('<link rel="stylesheet" href="../vendor/reveal.js/css/print/' + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper') + '.css" type="text/css" media="print">');
        </script>

        <link rel="stylesheet" href="../common/css/theme.10gen.css">
        <link rel="stylesheet" href="css/main.css">

        <!--[if lt IE 9]>
        <script src="../common/reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="state-background"></div>

            <div class="slides">
                <section data-state="title">
                    <h1><span class="logo-mongodb">MongoDB</span> Schema Design Workshop</h1>

                    <p class="bio">Jeremy Mikola<br><a href="http://twitter.com/jmikola">@jmikola</a></p>
                </section>

                <section>
                    <section data-markdown>
                        # Agenda

                        1. Basic Schema Design in MongoDB
                        2. Schema Design in each phase of an application's lifetime
                        3. Designing a schema for common patterns
                        4. Labs
                    </section>

                    <section data-markdown>
                        # Goals

                        * Learn the schema design process in MongoDB
                        * Practice applying common principles using examples
                        * Understand the implications of sharding
                    </section>

                    <section data-markdown>
                        # What is a schema and why is it important?
                    </section>
                </section>

                <section>
                    <section data-markdown data-state="library" class="bg">
                        # Schema

                        Maps concepts and relationships to data

                        Expectations are set for the data

                        Minimize overhead of iterative modifications

                        Compatibility is ensured
                    </section>

                    <section data-markdown data-state="normalize-denormalize">
                        ## Normalization

                        <div class="node-3">
                            <div class="node">
                                <span class="label">users</span>
                                <ul>
                                    <li><code>username</code></li>
                                    <li><code>first_name</code></li>
                                    <li><code>last_name</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&#8592;</div>
                            <div class="node">
                                <span class="label">books</span>
                                <ul>
                                    <li><code>title</code></li>
                                    <li><code>isbn</code></li>
                                    <li><code>language</code></li>
                                    <li><code>created_by</code></li>
                                    <li><code>author</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&#8594;</div>
                            <div class="node">
                                <span class="label">authors</span>
                                <ul>
                                    <li><code>first_name</code></li>
                                    <li><code>last_name</code></li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section data-markdown data-state="normalize-denormalize">
                        ## Denormalization

                        <div class="node-3">
                            <div class="node">
                                <span class="label">users</span>
                                <ul>
                                    <li><code>username</code></li>
                                    <li><code>first_name</code></li>
                                    <li><code>last_name</code></li>
                                </ul>
                            </div>
                            <div class="arrow">&#8592;</div>
                            <div class="node">
                                <span class="label">books</span>
                                <ul>
                                    <li><code>title</code></li>
                                    <li><code>isbn</code></li>
                                    <li><code>language</code></li>
                                    <li><code>created_by</code></li>
                                    <li class="embedded-object">
                                        <code>author</code>
                                        <ul>
                                            <li><code>first_name</code></li>
                                            <li><code>last_name</code></li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## What is schema design like in MongoDB?

                        Schema is defined at the application-level

                        Schema design is a part of each phase of an application's lifetime

                        There is no formula
                    </section>

                    <section data-markdown data-state="two-col-list">
                        ## MongoDB documents

                        Storage in BSON > <a href="http://bsonspec.org/">BSONSpec.org</a>

                        <div class="col-left">
                            <div class="list">
                                <span class="label">Scalars</span>
                                <ul>
                                    <li><code>Double</code></li>
                                    <li><code>UTF-8 String</code></li>
                                    <li><code>Binary</code></li>
                                    <li><code>ObjectId</code></li>
                                    <li><code>UTC DateTime</code></li>
                                    <li><code>Null</code></li>
                                    <li><code>Regular Expression</code></li>
                                    <li><code>32-bit Integer</code></li>
                                    <li><code>Timestamp</code></li>
                                    <li><code>64-bit Integer</code></li>
                                </ul>
                            </div>
                        </div>

                        <div class="col-right">
                            <div class="list-rich-types">
                                <span class="label">Rich Types</span>
                                <ul>
                                    <li><code>Sub-documents</code></li>
                                    <li><code>Arrays</code></li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section data-markdown>
                        ## Terminology

<pre><code class="language-javascript">{
    "mongodb" : "relational_db",
    "database" : "database",
    "collection" : "table",
    "document" : "row",
    "index" : "index",
    "sharding" : {
        "shard" : "partition",
        "shard key" : "partition key"
    }
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## 3 inputs to Schema Design in MongoDB

                        1. The data your application needs.
                        2. Your application's read usage of the data.
                        3. Your application's write usage of the data.
                    </section>
                </section>

                <section>
                    <section data-markdown data-state="library" class="bg">
                        ## Library web application
                        ## Case Study

                        Different schemas are possible
                    </section>

                    <section data-markdown>
                        ## Author schema
<pre><code class="language-javascript">{
    "_id": int,
    "first_name": string,
    "last_name": string
}</code></pre>
                    </section>

                    <section data-markdown>
                        ## User schema
<pre><code class="language-javascript">{
    "_id": int,
    "username": string,
    "password": string
}</code></pre>
                    </section>


                    <section data-markdown>
                        ## Book schema
<pre><code class="language-javascript">{
    "_id" : int,
    "title" : string
    "author" : int,
    "available" : boolean,
    "created_at" : date,
    "created_by" : date,
    "isbn" : string,
    "language" : string,
    "pages" : int,
    "publisher" : {
        "city" : string,
        "name" : string
    },
    "slug" : string,
    "subjects" : [ string, string ],
    reviews: [
       { "user": int, "text": string },
       { "user": int, "text": string } ],
}</code></pre>

                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Sample documents
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">  db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
}</code></pre>
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">  db.users.findOne()
{
    _id: 1,
    username: "emily@10gen.com",
    password: "slsjfk4odk84k209dlkdj90009283d"
}</code></pre>
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsbyss",
    slug: "9781857150193-the-great-gatsby",
    author:1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],

}</code></pre>
                    </section>
               </section>

               <section>
                    <section data-markdown>
                        # Embedded documents

                        What advantages do they have?

                        When should they be used?
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,<div class="code-highlight">    publisher: {
        publisher_name: "Everyman’s Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },</div>    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
}</code></pre>
                    </section>
               </section>

               <section>
                    <section data-markdown>
                        # Linked documents

                        What advantages does this approach have?

                        When should they be used?
                    </section>

                    <section data-markdown>
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",<div class="code-highlight">    author: 1, </div>    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
}</code></pre>
                    </section>

                    <section data-markdown>
                        <img src="img/memory.png">
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # Arrays

                        When should they be used?
                    </section>

                    <section data-markdown>
                        Array of Scalars
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },<div class="code-highlight">    subjects: ["Love stories", "1920s", "Jazz Age"], </div>    language: "English"
    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It's hard to..."} ],
}</code></pre>
                     </section>

                    <section data-markdown>
                        Array of documents
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",
    author: 1,
    available: true,
    isbn: "9781857150193",
    pages: 176,
    publisher: {
        publisher_name: "Everyman's Library",
        date: ISODate("1991-09-19T00:00:00Z"),
        publisher_city: "London"
    },
    subjects: ["Love stories", "1920s", "Jazz Age"],
    language: "English"<div class="code-highlight">    reviews: [
       { user: 1, text: "One of the best..."},
       { user: 2, text: "It’s hard to..."} ],</div>}</code></pre>
                     </section>

                </section>

                <section>
                    <section data-markdown>
                        # Schema design in each phase of an application's lifetime
                    </section>
                 </section>

                <section>
                    <section data-markdown>
                        # Development Phase
                        Basic CRUD functions
                    </section>
                 </section>

                 <section>
                    <section data-markdown>
                        # Create
<pre><code class="language-javascript">
    author = {  _id: 2,
               first_name: "Arthur",
               last_name: "Miller"
    }

    db.authors.insert(author)

</code></pre>
                        *  <a href="http://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-BSONObjectIDSpecification">_id</a> is unique and automatically indexed
                        * An ObjectId will be generated by MongoDB if not provided
                    </section>
                 </section>
                 <section>
                    <section data-markdown>
                        # Read
<pre><code class="language-javascript">
    db.authors.find({ "last_name": "Miller" })

    {  _id: 2,
       first_name: "Arthur",
       last_name: "Miller"
    }

</code></pre>
                    </section>
                    <section data-markdown>
                        ## Add an Index
<pre><code class="language-javascript">
    db.books.ensureIndex({ "slug": 1 })
</code></pre>
                        ## Examine the query
<pre><code class="language-javascript">
  db.books.find({ "slug": "the-great-gatsby" }).explain()
{<div class="code-highlight">    "cursor": "BtreeCursor slug_1",</div>    "isMultiKey" : false,
    "n" : 1,
    "nscannedObjects" : 1,
    "nscanned" : 1,
    "scanAndOrder" : false,
    "indexOnly" : false,
    "nYields" : 0,
    "nChunkSkips" : 0,
    "millis" : 0,
.....
}
</code></pre>
                    </section>

                     <section data-markdown>
                         ## Multi-key indexes on arrays

<pre><code class="language-javascript">
     db.books.ensureIndex({ "subjects": 1 })

</code></pre>
                     </section>

                    <section data-markdown>
                         ## Indexes on embedded document keys

<pre><code class="language-javascript">
     db.books.ensureIndex({ "publisher.name": 1 })

</code></pre>
                     </section>

                    <section data-markdown>
                        ## Query operators

                        * Conditional operators
                            * <code>$all, $exists, $mod, $ne, $nin, $nor, $or, $and, $size, $type</code>
                        * Regular Expressions
                        * Value in an array
                            * <code>$elemMatch</code>
                        * Cursor methods
                            * <code>count(), limit(), skip(), snapshot(), sort(), batchSize()</code>
                    </section>
                 </section>

                 <section>
                    <section data-markdown>
                        # Update
<pre><code class="language-javascript">
     review = { user: 1, text: "I did NOT like this book." }
     db.books.update({ _id: 1 }, {$push: {reviews: review }})

</code></pre>
                    </section>
                    <section data-markdown data-state="two-col-list">
                        ## Take advantage of atomic operations

                        <div class="col-left">
                            <div class="list">
                                <ul>
                                    <li><code>$set</code></li>
                                    <li><code>$unset</code></li>
                                    <li><code>$inc</code></li>
                                    <li><code>$push</code></li>
                                </ul>
                            </div>
                        </div>

                        <div class="col-right">
                            <div class="list">
                                <ul>
                                    <li><code>$pushAll</code></li>
                                    <li><code>$pull</code></li>
                                    <li><code>$pullAll</code></li>
                                    <li><code>$bit</code></li>
                                </ul>
                            </div>
                        </div>
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # Remove
<pre><code class="language-javascript">
     db.books.remove({ _id: 1 })

</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Production Phase
                        Evolve schema to meet application read and write patterns
                    </section>
                </section>

                <section>

                    <section data-markdown>
                        ## Read usage
                        Searches for author by first name
<pre><code class="language-javascript">
     authors = db.authors.find( { first_name: /^f.*/i }, {_id: 1})
     authorIds = authors.map(function(x) { return x._id; })
     db.books.find({author: { $in: authorIds } })

</code></pre>
                    </section>
                    <section data-markdown>
                        "Cache" the author name in an embedded document
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
<div class="code-highlight">    author: {
              _id: 1,
              first_name: "F. Scott",
              last_name: "Fitzgerald"
    },</div>    ...
}</code></pre>
                        Queries are now one step
<pre><code class="language-javascript">
  db.books.find({ author.first_name: /^f.*/i })

</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Write usage
                        Review a book
<pre><code class="language-javascript">
     review = { user: 1,
                text: "I did NOT like this book.",
                rating: 1 }

     db.books.update({ _id: 3 }, {$push: {reviews: review }})

</code></pre>
                        * 16mb document size limit
                        * Possible storage fragmentation with many updates
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # Iterative Modifications
                        Schema design is evolutionary
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Allow users to browse by book subject
<pre><code class="language-javascript">  db.subjects.findOne()
{   _id: 1,
    name: "American Literature",
    sub_category: {
                     name: "1920s",
                     sub_category: { name: "Jazz Age" }
                   }
}</code></pre>
                        * How can you search this collection?
                        * Be aware of document size limitations
                        * Benefit from hierarchy being in same document
                    </section>

                    <section data-markdown>
                        ## Implementing a tree structure
<pre><code class="language-javascript">  db.subjects.find()
{   _id: "American Literature"}
{   _id : "1920s",
          ancestors: ["American Literature"],
          parent: "American Literature"
}
{   _id: "Jazz Age",
         ancestors: ["American Literature", "1920s"],
         parent: "1920s"
}
{   _id: "Jazz Age in New York",
         ancestors: ["American Literature", "1920s", "Jazz Age"],
         parent: "Jazz Age"
}
</code></pre>
                        Find sub-categories of a given subject
<pre><code class="language-javascript">  db.subjects.find({ ancestors: "1920s" })
</code></pre>

                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Common patterns
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # One-to-one
                    </section>

                    <section data-markdown>
                        # Linking
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",<div class="code-highlight">    author: 1,</div>    ....
}</code></pre>

<pre><code class="language-javascript">  db.authors.findOne(1)
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
}</code></pre>
                    </section>
                    <section data-markdown>
                        ## Embedded document
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",<div class="code-highlight">    author: {
    first_name: "F. Scott",
    last_name: "Fitzgerald"
},</div>    ....
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # One-to-many
                    </section>

                    <section data-markdown>
                        ## Array of documents
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",<div class="code-highlight">    authors: [
      { first_name: "F. Scott",
        last_name: "Fitzgerald"},
      { first_name: "Another",
        last_name: "Author"}
     ],</div>    ....
}</code></pre>
                        * Use $slice operator to return a subset of authors
                        * Some queries are more difficult, like finding last array element
                    </section>
                    <section data-markdown>
                        ## Array of ids
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",
    slug: "9781857150193-the-great-gatsby",<div class="code-highlight">    authors: [1, 5]
</div>    ....
}</code></pre>
                        * More flexible
                        * More queries necessary
                    </section>
                    <section data-markdown>
                        ## *direction is a choice
<pre><code class="language-javascript">  db.authors.findOne()
{
    _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald",
    books: [1, 3, 20]
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        # Many-to-many
                    </section>

                    <section data-markdown>
                        ## Array of ids on both ends
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",<div class="code-highlight">    authors: [1, 5]
</div>    ....
}</code></pre>

<pre><code class="language-javascript">  db.authors.findOne()
{   _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald",<div class="code-highlight">    books: [1, 3, 20]</div> }</code></pre>

                        Query for all books by a given author
<pre><code class="language-javascript">  db.books.find({ authors : 1 })
</code></pre>
                        Query for all authors of a given book
<pre><code class="language-javascript">  db.authors.find({ book : 1 })
</code></pre>

                    </section>

                    <section data-markdown>
                        ## Array of ids on one end
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Great Gatsby",<div class="code-highlight">    authors: [1, 5]
</div>    ....
}</code></pre>

<pre><code class="language-javascript">  db.authors.findOne()
{   _id: 1,
    first_name: "F. Scott",
    last_name: "Fitzgerald"
}</code></pre>

                        Query for all books by a given author
<pre><code class="language-javascript">  db.books.find({ authors : 1 })
</code></pre>
                        Query for all authors of a given book
<pre><code class="language-javascript">  book = db.books.findOne({ title : "The Great Gatsby" })
  db.authors.find( { _id : { $in : book.authors }})
</code></pre>

                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # Single collection inheritance

                        Take advantage of MongoDB's features

                        * Missing values are not stored
                        * Sparse indexes index only present values
                    </section>

                    <section data-markdown>
                        ## Take advantage of MongoDB's flexibility
<pre><code class="language-javascript">  db.books.findOne()
{   _id: 1,
    title: "The Wizard Chase",
    series_title: "The Wizard's Trilogy",<div class="code-highlight">    volume: 2</div>    ....
}</code></pre>
                        Find all books that are part of a series
<pre><code class="language-javascript">
  db.books.find({ volume: { $exists: true }})

</code></pre>
                    </section>

                    <section data-markdown>
                        ## Index only present values
<pre><code class="language-javascript">
  db.books.ensureIndex({ series_title: 1 }, {sparse: true } )

</code></pre>
<pre><code class="language-javascript">
  db.books.ensureIndex({ volume: 1 }, {sparse: true } )

</code></pre>
                    </section>

                </section>

                <section>
                    <section data-markdown>
                        # I Like Turtles
                    </section>
                </section>

                <section>
                    <section data-markdown class="ul-2col">
                        ## Exercise #1

                        Design a schema for users and their book reviews.

                        * Users
                            * username (string)
                            * email (string)
                        * Reviews
                            * text (string)
                            * rating (integer)
                            * created_at (date)

                        *Usernames are immutable.*
                    </section>

                    <section data-markdown>
                        ### Exercise #1: Solution A

                        Reviews may be queried by user or book.

                        <pre><code class="language-javascript">// db.users (one document per user)
{ _id: ObjectId("…"),
  username: "bob",
  email: "bob@example.com"
}</code></pre>

                        <pre><code class="language-javascript">// db.reviews (one document per review)
{ _id: ObjectId("…"),
  user: ObjectId("…"),
  book: ObjectId("…"),
  rating: 5,
  text: "This book is excellent!",
  created_at: ISODate("2012-10-10T21:14:07.096Z")
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #1: Solution B

                        Optimized to retrieve reviews for a user.

                        <pre><code class="language-javascript">// db.users (one document per user with all reviews)
{ _id: ObjectId("…"),
  username: "bob",
  email: "bob@example.com",
  reviews: [
    { book: ObjectId("…"),
      rating: 5,
      text: "This book is excellent!",
      created_at: ISODate("2012-10-10T21:14:07.096Z")
    }
  ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #1: Solution C

                        Optimized to retrieve reviews for a book.

                        <pre><code class="language-javascript">// db.users (one document per user)
{ _id: ObjectId("…"),
  username: "bob",
  email: "bob@example.com"
}</code></pre>

                        <pre><code class="language-javascript">// db.books (one document per book with all reviews)
{ _id: ObjectId("…"),
  // Other book fields
  reviews: [
    { user: ObjectId("…"),
      rating: 5,
      text: "This book is excellent!",
      created_at: ISODate("2012-10-10T21:14:07.096Z")
    }
  ]
}</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #2

                        Display a user's most recent 10 book reviews.

                        Make efficient use of memory and disk seeks.
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Store users' reviews in monthly buckets.

                        <pre><code class="language-javascript">// db.reviews (one document per user per month)
{ _id: "bob-2012-10",
  reviews: [
    { _id: ObjectId("…"),
      rating: 5,
      text: "This book is excellent!",
      created_at: ISODate("2012-10-10T21:14:07.096Z")
    },
    { _id: ObjectId("…"),
      rating: 2,
      text: "I didn't really enjoy this book.",
      created_at: ISODate("2012-10-11T20:12:50.594Z")
    }
  ]
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Adding a new review to the appropriate bucket.

                        <pre><code class="language-javascript">myReview = {
  rating: 3,
  text: "An average read.",
  created_at: ISODate("2012-10-13T12:26:11.502Z")
};

db.reviews.update(
  { _id: "bob-2012-10" },
  { $push: { reviews: myReview }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Display a user's most recent 10 book reviews.

                        <pre><code class="language-javascript">cursor = db.reviews.find(
  { _id: /^bob-/ },
  { reviews: { $slice: 10 }}
).sort({ _id: -1 });

num = 0;

while (cursor.hasNext() &amp;&amp; num &lt; 10) {
  doc = cursor.next();

  for (var i = 0; i &lt; doc.reviews.length && num < 10; ++i, ++num) {
    printjson(doc.reviews[i]);
  }
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #2: Solution

                        Deleting a review.

                        <pre><code class="language-javascript">cursor = db.reviews.update(
  { _id: "bob-2012-10" },
  { $pull: {
      reviews: { created_at: ISODate("2012-10-13T12:26:11.502Z") }
    }
  }
);</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #3

                        Allow users to follow one another.

                        * User sends a follow request
                        * Followee approves or not
                        * Requests time out after seven days

                        Approval process is asynchronous.
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        * Need to maintain order and state
                        * Ensure that updates are atomic

                        <pre><code class="language-javascript">db.approvals.insert({
  _id: { follower: "bob", followee: "mary" },
  in_progress: false,
  approved: false,
  priority: 1,
});

// Find the highest priority approval and mark as in progress
approval = db.approvals.findAndModify({
  query: { in_progress: false },
  sort: { priority: -1 },
  update: { $set: { in_progress: true, started: new ISODate() }},
  new: true
});</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        <pre><code class="language-javascript">{
  _id: { follower: "bob", followee: "mary" },
  in_progress: true, // updated
  approved: false,
  priority: 1,
  started: ISODate("2012-10-11T22:09:42.542Z") // added
}</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        <pre><code class="language-javascript">// Followee approves request
db.approvals.update(
  { _id: { follower: "bob", followee: "mary" }},
  { $set: { inprogress: false, approved: true }}
);</code></pre>
                    </section>

                    <section data-markdown>
                        ### Exercise #3: Solution

                        <pre><code class="language-javascript">limit = new Date();
limit.setDate(limit.getDate() - 7);

// Time out requests after seven days
db.approvals.update(
  { inprogress: true, started: { $lt: limit }},
  { $set: { inprogress: false, approved: false }}
);</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #4

                        Allow users to upvote a review.

                        * Users can upvote a review only once
                        * Display a review's current upvotes
                    </section>

                    <section data-markdown>
                        ## Exercise #4: Solution

                        <pre><code class="language-javascript">// db.votes (one document per voter per review)
db.votes.insert({
  review: ObjectId("…"),
  user: ObjectId("…")
});

// Unique index ensures users can't vote twice
db.votes.ensureIndex({ review: 1, user: 1 }, { unique: true });

// Count the number of upvotes for a review
db.votes.count({ review: ObjectId("…") });</code></pre>
                    </section>

                    <section data-markdown>
                        ## Exercise #4: Solution

                        Denormalize upvote totals on reviews.

                        <pre><code class="language-javascript">db.reviews.update(
  { _id: ObjectId("…") },
  { $inc: { votes: 1 }}
});</code></pre>
                    </section>
                </section>

                <section>
                    <section data-markdown>
                        ## Exercise #5

                        Tracking time series data.

                        * Count upvotes by: day, hour, minute
                        * Show time series of votes cast
                    </section>

                    <section data-markdown>
                        ## Exercise #5: Solution

                        <pre><code class="language-javascript">// db.votes_ts (one document per review per day of votes)
db.votes_ts.update(
  { review: ObjectId("…"),
    day: ISODate("2012-10-11T00:00:00.000Z") }
  { user: ObjectId("…")
});

// Unique index ensures users can't vote twice
db.votes.ensureIndex({ review: 1, user: 1 }, { unique: true });

// Count the number of upvotes for a review
db.votes.count({ review: ObjectId("…") });</code></pre>
                    </section>

                    <section data-markdown>
                        ## Exercise #4: Solution

                        Denormalize upvote totals on reviews.

                        <pre><code class="language-javascript">db.reviews.update(
  { _id: ObjectId("…") },
  { $inc: { votes: 1 }}
});</code></pre>
                    </section>
                </section>
            </div>

            <div class="footer"></div>
        </div>

        <script src="../vendor/reveal.js/lib/js/head.min.js"></script>
        <script src="../vendor/reveal.js/js/reveal.js"></script>
        <script src="../common/js/reveal.js"></script>
    </body>
</html>
